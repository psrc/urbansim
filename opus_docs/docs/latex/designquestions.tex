% $Id: designquestions.tex,v 1.12 2007/06/01 23:49:22 borning Exp $

% Copyright (c) 2005-2007 Center for Urban Simulation and Policy Analysis,
% University of Washington.  Permission is granted to copy, distribute and/or
% modify this document under the terms of the GNU Free Documentation License,
% Version 1.2 or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
% A copy of the license is included in the section entitled "GNU Free
% Documentation License".

\chapter{Design Questions, Decisions, and Context}

This chapter lists some of the design questions, decisions, and discussions
made as we designed and built Opus.  We hope that providing this information
will help people understand, use, and extend the Opus architecture in a way
that preserves what is good and fixes what is not so good.  They also may help
explain why we did things that may not be obvious otherwise.

Please feel free to send us additional architectural questions, which we'll try
to add to this list.

\newenvironment{design-question}{
\begin{flushright}
\begin{tabular}{|p{0.9\linewidth}|}\hline\emph{Guideline:}
} { \\ \hline
\end{tabular}
\end{flushright}
}

\begin{itemize}
  \item {\bf What data stores should we support?} \emph{Make it easy to get and
  store data from many different data stores, such as relational databases or
  files.}

  We already knew that different MPOs would have different relational
  databases, so we needed to allow them to use the data store best for them. In
  addition, using file stores is useful for testing and for caching datastore
  attributes.

  \item As much as possible, allow an Opus user to easily be able to modify or
  extend the behavior of Opus without making any changes to the installed set
  of Opus packages.

  \item {\bf Should we create our own Opus language, in the way that R \rindex has its
  own language?} \emph{No.}

  Whereever possible, use Python's \pythonindex language to do what is necessary, rather
  than creating our own language.  The goal is that Opus should be a set of
  Python \pythonindex packages and not change any of Python's \pythonindex default behavior.  We did not
  want to define our own language, as R \rindex did, since we believed we do not have a
  sufficient understanding of what the language should be.

  \item Minimize the number of ``usage models'' or ``object models'' that a user
  has to know in order to use Opus.  For instance, we struggled to minimize the
  number of different types of paths that may be used for naming an Opus
  variable, e.g. ``gridcell.grid_id'', ``urbansim.gridcell.grid_id'', and ???.

  \item Favor transparency over cool code that might make the user's life
  simpler.  For instance, we used to specify variables \variablesindex with just the last part
  of their name, e.g. ``average_household_income'', but changed to using a
  fully-qualified path, e.g.
  ``urbansim.gridcell.average_household_income''. This removed the
  ambiguity about which dataset \datasetindex this variable \variablesindex lived in, made it clearer when
  variables \variablesindex were new definitions provided by a user versus ones that came with
  urbansim, eliminated our need to arbitrarily decide on a search order in
  which to look in different packages for this variable definition, avoided
  problems associated with search paths, etc.  The tradeoff was that the user
  would have to type some more characters.  On the other hand, we are planning
  to build more tools to automatically create this text from GUIs, so the
  amount of typing in the future will diminish.

  \item {\bf Where should unit test live?} \emph{In same file as code.}

  Having the unit tests in the same file as the code helps reinforce that the
  tests are part of the definition of the class.  It also makes it much easier
  to find the tests for a class.

  \item {\bf How can a modeler easily build a new model from a set of common
  model ``parts''?} \emph{Models may be composed of ``model steps'', where each
  model step is a function on data.}

  \item {\bf How can a modeler add a new model without changing any of the
  installed Opus code?}

  \item {\bf How can a modeler add a new variable without changing any of the
  installed Opus code?}

  \item {\bf How can a user trust the Opus code?} \emph{Make the code as
  transparent as possible.  Have automated, meaningful tests for all the
  important parts.}

  This is perhaps one of the most important design questions for Opus.

  \item {\bf How can the user know what to do when there is a failure?}
  \emph{Never hide exceptions that indicate actual errors.  Provide useful
  error messages.  Provide good debugging support.}

  We still need to do more work on this item.

  \item {\bf How can Opus minimize the amount of memory used?}

  \item {\bf How can the user know the ``pedigree'' of the results?}

  This ``pedigree'' includes which tables were found from in which database,
  which version of code was used, what configuration was used for this run, etc.

  \item {\bf How can the user know the state of a simulation run?}

  \item {\bf How can the user define a ``scenario`` that is a slight change to
  a baseyear database?}

  \item {\bf How make it easy to re-start a failed simulation?} \emph{Use the
  \code{run_manager/restart_run.py} script to restart a run from the
  information in the \code{run_activity} table.}

  \item {\bf How to know when to re-compute a variable's \variablesindex value?} \emph{Opus'
  dataset keeps track of the versions of a variable \variablesindex and of all the inputs used
  to compute that variable. \variablesindex When getting a variable's \variablesindex values, the dataset \datasetindex
  checks to see if the inputs' versions have changed.  If so, it recomputes the
  variable. \variablesindex This is done recursively, so ensure that a variable \variablesindex is computed
  exactly when needed, and never before when needed.}

  \item {\bf How to make it easy to specify a new variable?} \variablesindex \emph{Opus uses
  several techniques for this.
  \begin{itemize}
    \item A clean and simple \code{Variable} \variablesindex class makes it easy to specify
    variables. \variablesindex
    \item A simplified equation syntax to specify some variable \variablesindex computations in
    the ``name'' of the variable, \variablesindex e.g.
    \code{ln(urbansim.gridcell.total_land_price)} computes
    the natural log of the \code{urbansim.gridcell.total_land_price}
    without requiring any extra Python \pythonindex code.
    \item A simple pattern substitution syntax to allow a ``family'' of related
    variables \variablesindex to specified in a single variable, e.g.
    \code{urbansim.gridcell.is_plan_type_DDD} will match any variable \variablesindex with
    a set of digits at the \code{DDD}, such as
    \code{urbansim.gridcell.is_plan_type_10}.
  \end{itemize}
    }
\end{itemize}
