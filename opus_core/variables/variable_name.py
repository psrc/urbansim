# Opus/UrbanSim urban simulation software.
# Copyright (C) 2005-2009 University of Washington
# See opus_core/LICENSE 


class VariableName(object):
    """Object representing the name of an Opus variable.  The fields are as follows.  We'll use
    the variable 'urbansim.gridcell.population as a running example'.
    
    expression: a string that defines the variable name, e.g. 'urbansim.gridcell.population'
        or 'ln(urbansim.gridcell.population)'
    _squished_expression: same as expression, but with whitespace removed
    package_name: the name of the package containing the variable definition (e.g. 'urbansim'), or None 
    dataset_name: the name of the dataset (e.g. 'gridcell'), or None for primary attributes or expressions involving interaction sets
    interaction_set_names: tuple of names of the components of the interaction set, for expressions for variables on interaction sets
    short_name: the name of the attribute that holds the variable value in the dataset, e.g. 'population'
        (this is required; it can't be None)
    alias: an alias for the variable, or None.  Example: for 'lnpop = ln(urbansim.gridcell.population)' 
        the alias is 'lnpop'
   """
 
    # Class dictionary of expressions for which variables have already been generated.  The keys are
    # strings (the source expression, with whitespace removed).  The values are tuples 
    # (package_name, dataset_name, short_name, alias, autogen_class)
    # Reuse this information when possible (in particular, don't generate a new autogen class if there already
    # is one for this expression)
    _cache = {}
    # Class dictionary of autogenerated classes.  The keys are strings (the class name) and the values are 
    # the corresponding classes.
    _autogen_classes = {}
    
    # TEMPORARY VARIABLE - used while expression compiler rewrite is in progress
    # TODO: remove this when rewrite is complete
    use_inprocess_compiler = False

    def __init__(self, expression):
        self._expression = expression
        # squished is a copy of the expression with whitespace removed
        # by using this in the cache we make expressions equivalent that differ only by whitespace
        squished = expression.replace(' ', '')

        self._squished_expression = squished
        if squished not in self._cache:
            # put the import here to avoid a circular import at the top level
            # from opus_core.variables.autogen_variable_factory import AutogenVariableFactory
            # TODO: remove this when expression compiler rewrite is complete
            if self.use_inprocess_compiler:
                from inprocess.borning.expressions.autogen_variable_factory import AutogenVariableFactory
            else:
                from opus_core.variables.autogen_variable_factory import AutogenVariableFactory
            t = AutogenVariableFactory(expression).generate_variable_name_tuple()
            self._cache[squished] = t
        (package_name, dataset_names, short_name, alias, autogen_class) = self._cache[squished]
        self._package_name = package_name
        n = len(dataset_names)
        if n==0:
            self._dataset_name = None
            self._interaction_set_names = None
        elif n==1:
            self._dataset_name = dataset_names[0]
            self._interaction_set_names = None
        elif n==2:
            self._dataset_name = None
            self._interaction_set_names = dataset_names
        else:
            raise ValueError, "couldn't determine dataset to which this expression applies -- too many dataset names.  Dataset names = %s" % str(datasetnames)
        self._short_name = short_name
        self._alias = alias
        if autogen_class is not None:
            self._autogen_classes[short_name] = autogen_class

    def get_expression(self):
        return self._expression

    def get_package_name(self):
        return self._package_name

    def get_dataset_name(self):
        return self._dataset_name

    def get_interaction_set_names(self):
        return self._interaction_set_names

    def get_short_name(self):
        return self._short_name
    
    def get_squished_expression(self):
        return self._squished_expression
    
    def get_alias(self):
        if self._alias is None:
            return self.get_short_name()
        else:
            return self._alias

    def get_autogen_class(self):
        """return the autogenerated class for this variable name, or None if there isn't one"""
        return self._autogen_classes.get(self.get_short_name(), None)

    # setters
    def set_dataset_name(self, n):
        self._dataset_name = n

    # comparison operations
    def __eq__(self, n):
        return self._squished_expression == n._squished_expression

    def __ne__(self, n):
        return not (self==n)

# CONSTANTS  
# initial part of the name for autogenerated variable classes
autogenvar_prefix = 'autogenvar'

# FUNCTIONS
def is_anonymous_autogen_name(str):
    """return True if str is the attribute name for an autogenerated variable without an alias"""
    return str.startswith(autogenvar_prefix)


from opus_core.tests import opus_unittest
class Tests(opus_unittest.OpusTestCase):

    def test_eq_and_neq(self):
        v1 = VariableName('p = urbansim.gridcell.population')
        v2 = VariableName('p=urbansim.gridcell.population')  # same as v1, but no spaces
        v3 = VariableName('x')
        self.assert_(v1==v2)
        self.assert_(not (v1!=v2))
        self.assert_(v1!=v3)
        self.assert_(not (v1==v3))

    def test_is_anonymous_autogen_name(self):
        self.assert_(is_anonymous_autogen_name('autogenvar05'))
        self.assert_(not is_anonymous_autogen_name('population'))
        
if __name__=='__main__':
    opus_unittest.main()
