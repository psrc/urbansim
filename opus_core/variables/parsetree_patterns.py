# Opus/UrbanSim urban simulation software.
# Copyright (C) 2010-2011 University of California, Berkeley, 2005-2009 University of Washington
# See opus_core/LICENSE 

# Parse tree patterns for use in autogenerating variable classes.
# See the file utils/parsetree_pattern_generator for utility functions for generating new tree fragments.
# these parse trees are only guaranteed to work for Python 2.5 and 2.6

import symbol, token, sys
     
# ************************************************************************************
# The patterns named FULL_TREE_* match entire trees (as generated by the parser)
# ************************************************************************************
python_version = sys.version_info[:2]

if python_version == (2, 7):
    endtoken = (token.NEWLINE, ''), (token.ENDMARKER, '')
else:
    endtoken = ((token.ENDMARKER, ''), )

# This pattern matches a tree consisting of an expression (as opposed to a statement)
FULL_TREE_EXPRESSION =  \
    (symbol.file_input,
     (symbol.stmt,
      (symbol.simple_stmt,
       (symbol.small_stmt,
        (symbol.expr_stmt, ['expr'])),
       (token.NEWLINE, ''))),
     ) + endtoken

# This pattern matches a tree consisting of a single assignment statement alias=expr
FULL_TREE_ASSIGNMENT =  \
    (symbol.file_input,
     (symbol.stmt,
      (symbol.simple_stmt,
       (symbol.small_stmt,
        (symbol.expr_stmt,
         (symbol.testlist,
          (symbol.test,
           (symbol.or_test,           
            (symbol.and_test,
             (symbol.not_test,
              (symbol.comparison,
               (symbol.expr,
                (symbol.xor_expr,
                 (symbol.and_expr,
                  (symbol.shift_expr,
                   (symbol.arith_expr,
                    (symbol.term,
                     (symbol.factor,
                      (symbol.power,
                       (symbol.atom, (token.NAME, ['alias'])))))))))))))))),
            (token.EQUAL, '='), ['expr'])),
       (token.NEWLINE, ''))),
     ) + endtoken

# ************************************************************************************
# The patterns named EXPRESSION_IS_* match expressions that consist just of the named item
# ************************************************************************************

# This pattern matches an expression that is simply a fully qualified variable (not a more
# complex expression).
EXPRESSION_IS_FULLY_QUALIFIED_VARIABLE =  \
    (symbol.testlist,
      (symbol.test,
       (symbol.or_test,                  
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom, (token.NAME, ['package'])),
                   (symbol.trailer,
                    (token.DOT, '.'),
                    (token.NAME, ['dataset'])),
                   (symbol.trailer,
                    (token.DOT, '.'),
                    (token.NAME, ['shortname']))))))))))))))))

# This pattern matches an expression that is simply a dataset qualified variable (not a more
# complex expression).
EXPRESSION_IS_DATASET_QUALIFIED_VARIABLE =  \
    (symbol.testlist,
      (symbol.test,
       (symbol.or_test,                  
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom, (token.NAME, ['dataset'])),
                   (symbol.trailer,
                    (token.DOT, '.'),
                    (token.NAME, ['shortname']))))))))))))))))

# This pattern matches an expression that is simply an attribute (not a more
# complex expression).
EXPRESSION_IS_ATTRIBUTE =  \
    (symbol.testlist,
      (symbol.test,
       (symbol.or_test,                  
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom, (token.NAME, ['shortname']))))))))))))))))

# ************************************************************************************
# The patterns named SUBPATTERN_* match bits of expressions consisting of the named item.
# These can be used in picking out bits of a more complex tree.
# ************************************************************************************

# Match a fully qualified variable, perhaps raised to a power.  (The power part is optional.)
# Because of Python's grammar we need to include the power part in this pattern.
# Minor kludge: this pattern will also match 'urbansim.gridcell.population**' (i.e. missing
# the exponent).  However, we would never get far enough to feed that tree to the matcher, 
# since it would have caused a parse error earlier.  (Iit's not part of a legal Python expression.)
# The same thing is true for the patterns for dataset-qualified attribute and attribute.
SUBPATTERN_FULLY_QUALIFIED_VARIABLE =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['package'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['dataset'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['shortname'])),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

SUBPATTERN_FULLY_QUALIFIED_VARIABLE_WITH_CAST =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['package'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['dataset'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['shortname'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, 'astype')),
     (symbol.trailer,
      (token.LPAR, '('),
       (symbol.arglist,
        (symbol.argument,
         (symbol.test,
          (symbol.or_test,
           (symbol.and_test,
            (symbol.not_test,
             (symbol.comparison,
              (symbol.expr,
               (symbol.xor_expr,
                (symbol.and_expr,
                 (symbol.shift_expr,
                  (symbol.arith_expr,
                   (symbol.term,
                    (symbol.factor,
                     (symbol.power,
                      (symbol.atom,
                       (token.NAME, ['type']))))))))))))))))),
      (token.RPAR, ')')),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

SUBPATTERN_DATASET_QUALIFIED_ATTRIBUTE =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['dataset'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['shortname'])),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

SUBPATTERN_DATASET_QUALIFIED_ATTRIBUTE_WITH_CAST =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['dataset'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['shortname'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, 'astype')),
     (symbol.trailer,
      (token.LPAR, '('),
       (symbol.arglist,
        (symbol.argument,
         (symbol.test,
          (symbol.or_test,
           (symbol.and_test,
            (symbol.not_test,
             (symbol.comparison,
              (symbol.expr,
               (symbol.xor_expr,
                (symbol.and_expr,
                 (symbol.shift_expr,
                  (symbol.arith_expr,
                   (symbol.term,
                    (symbol.factor,
                     (symbol.power,
                      (symbol.atom,
                       (token.NAME, ['type']))))))))))))))))),
      (token.RPAR, ')')),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

# match a single attribute name
SUBPATTERN_ATTRIBUTE =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['shortname'])),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

SUBPATTERN_ATTRIBUTE_WITH_CAST =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['shortname'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, 'astype')),
     (symbol.trailer,
      (token.LPAR, '('),
       (symbol.arglist,
        (symbol.argument,
         (symbol.test,
          (symbol.or_test,
           (symbol.and_test,
            (symbol.not_test,
             (symbol.comparison,
              (symbol.expr,
               (symbol.xor_expr,
                (symbol.and_expr,
                 (symbol.shift_expr,
                  (symbol.arith_expr,
                   (symbol.term,
                    (symbol.factor,
                     (symbol.power,
                      (symbol.atom,
                       (token.NAME, ['type']))))))))))))))))),
      (token.RPAR, ')')),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])


SUBPATTERN_ARGLIST = symbol.arglist

# Match a method call (for use in matching functions in interaction set expressions and aggregations)
# For this pattern there must be 1 or more arguments (zero-argument methods won't match)
SUBPATTERN_METHOD_CALL_WITH_ARGS =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['receiver'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['method'])),
     (symbol.trailer,
      (token.LPAR, '('),
      ['args'],
      (token.RPAR, ')')),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

SUBPATTERN_METHOD_CALL_WITH_ARGS_WITH_CAST =  \
    (symbol.power,
     (symbol.atom, (token.NAME, ['receiver'])),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, ['method'])),
     (symbol.trailer,
      (token.LPAR, '('),
      ['args'],
      (token.RPAR, ')')),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, 'astype')),
     (symbol.trailer,
      (token.LPAR, '('),
       (symbol.arglist,
        (symbol.argument,
         (symbol.test,
          (symbol.or_test,
           (symbol.and_test,
            (symbol.not_test,
             (symbol.comparison,
              (symbol.expr,
               (symbol.xor_expr,
                (symbol.and_expr,
                 (symbol.shift_expr,
                  (symbol.arith_expr,
                   (symbol.term,
                    (symbol.factor,
                     (symbol.power,
                      (symbol.atom,
                       (token.NAME, ['type']))))))))))))))))),
      (token.RPAR, ')')),
     ['?', (token.DOUBLESTAR, '**')],
     ['?', (symbol.factor, (symbol.power, (symbol.atom, (token.NUMBER, ['exponent']))))])

SUBPATTERN_NAME = (token.NAME, ['name'])

SUBPATTERN_NUMBER_OF_AGENTS = \
    (symbol.arglist,
     (symbol.argument,
      (symbol.test,
       (symbol.or_test,
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom,
                    (token.NAME,
                     ['agent'])))))))))))))))))
    
SUBPATTERN_AGENT_TIMES_CHOICE = \
    (symbol.arglist,
     (symbol.argument,
      (symbol.test,
       (symbol.or_test,
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom,
                    (token.NAME,
                     ['attribute'])))))))))))))))))

# Pattern that matches the arguments to a call to aggregate(...) and disaggregate(...)
# The first argument is required.  The remaining 2 arguments are optional.
SUBPATTERN_AGGREGATION =  \
    (symbol.arglist,
     ['arg1'],
     ['?', (token.COMMA, ',')],
     ['?', ['arg2']],
     ['?', (token.COMMA, ',')],
     ['?', ['arg3']])

# match an argument, optionally with a keyword
SUBPATTERN_ARGUMENT = \
    (symbol.argument,
     ['part1'],
     ['?', (token.EQUAL, '=')],
     ['?', ['part2']])

# match an argument that is simply a fully qualified variable (not a more complex expression)
SUBPATTERN_FULLY_QUALIFIED_VARIABLE_ARG =  \
      (symbol.test,
       (symbol.or_test,                  
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom, (token.NAME, ['package'])),
                   (symbol.trailer,
                    (token.DOT, '.'),
                    (token.NAME, ['dataset'])),
                   (symbol.trailer,
                    (token.DOT, '.'),
                    (token.NAME, ['shortname'])))))))))))))))

# match an expression that is simply a dataset qualified variable (not a more complex expression)
SUBPATTERN_DATASET_QUALIFIED_VARIABLE_ARG =  \
      (symbol.test,
       (symbol.or_test,                  
        (symbol.and_test,
         (symbol.not_test,
          (symbol.comparison,
           (symbol.expr,
            (symbol.xor_expr,
             (symbol.and_expr,
              (symbol.shift_expr,
               (symbol.arith_expr,
                (symbol.term,
                 (symbol.factor,
                  (symbol.power,
                   (symbol.atom, (token.NAME, ['dataset'])),
                   (symbol.trailer,
                    (token.DOT, '.'),
                    (token.NAME, ['shortname'])))))))))))))))

# match an argument consisting of just a name
SUBPATTERN_NAME_ARG = \
    (symbol.test,
     (symbol.or_test,           
      (symbol.and_test,
       (symbol.not_test,
        (symbol.comparison,
         (symbol.expr,
          (symbol.xor_expr,
           (symbol.and_expr,
            (symbol.shift_expr,
             (symbol.arith_expr,
              (symbol.term,
               (symbol.factor,
                (symbol.power,
                 (symbol.atom,
                  (token.NAME, ['name'])))))))))))))))

# match an argument consisting of a list (either empty or nonempty)
SUBPATTERN_LIST_ARG = \
    (symbol.test,
     (symbol.or_test,           
      (symbol.and_test,
       (symbol.not_test,
        (symbol.comparison,
         (symbol.expr,
          (symbol.xor_expr,
           (symbol.and_expr,
            (symbol.shift_expr,
             (symbol.arith_expr,
              (symbol.term,
               (symbol.factor,
                (symbol.power,
                 (symbol.atom,
                  (token.LSQB, '['),
                  ['?', ['list']],  # if the list is empty this will match the right bracket; otherwise the list contents
                  ['?', (token.RSQB, ']')]))))))))))))))
    
    
# match an entire method call, without type conversions or exponentiation or other clutter
# (used when finding a replacement parsetree for an aggregation/disaggregation call
FULL_EXPRESSION_METHOD_CALL = \
    (symbol.testlist,
     (symbol.test,
      (symbol.or_test,
       (symbol.and_test,
        (symbol.not_test,
         (symbol.comparison,
          (symbol.expr,
           (symbol.xor_expr,
            (symbol.and_expr,
             (symbol.shift_expr,
              (symbol.arith_expr,
               (symbol.term,
                (symbol.factor,
                 (symbol.power,
                  (symbol.atom, (token.NAME, ['receiver'])),
                  (symbol.trailer,
                   (token.DOT, '.'),
                   (token.NAME, ['method'])),
                   (symbol.trailer,
                    (token.LPAR, '('),
                    ['args'],
                    (token.RPAR, ')'))))))))))))))))

DATASET_QUALIFIED_VARIABLE_TEMPLATE =  \
    (symbol.power,
     (symbol.atom, (token.NAME, 'dataset')),
     (symbol.trailer,
      (token.DOT, '.'),
      (token.NAME, 'attribute')))

