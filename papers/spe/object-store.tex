%% $Id: object-store.tex,v 1.11 2001/08/18 00:56:25 borning Exp $

\subsection{Object Store}
\label{sec:object-store}

The representations of agents in the world (such as households and
businesses), and the objects they operate upon (such as buildings and land
parcels), are held in the Object Store.  The Object Store serves as an
in-memory database that can be queried or updated, and that supports
filtering on entity attributes.

The basic interface to the Object Store is through its \varnm{postQuery}
and \varnm{postUpdate} methods.  A model constructs a \varnm{Query} object
by filling in the object type and set of fields to query for (e.g., the
age and size category fields for households), and adds any \varnm{Filter}
objects to the \varnm{Query} as desired (e.g., a filter
that returns only households with a given number of workers).  The
\varnm{postQuery} invocation returns a \varnm{QueryResult} object, which
contains a copy of all relevant data from the Object Store, including
internal object {IDs} for all values returned.  
% Results are returned in parallel arrays (one array per field) 
% to avoid Java object-level memory overhead.  
Updates work in a symmetric fashion, with a model constructing
a \varnm{Update} object whose form is similar to \varnm{QueryResult} with
the addition of the update type (create, modify, remove).

From a software engineering point of view, the Object Store also serves to
encapsulate representation decisions about the entities in the simulation.
From outside the Object Store, these act as traditional instances in an
object-oriented language.  However, they are represented more efficiently
within the Object Store.  Further, rather than defining these objects by
writing a class definition, we use information in the Model Definition
Files to give a description of just the portion of each object relevant to
the corresponding model.  These partial descriptions are then integrated by
the system during the code generation phase to produce the eventual object
definition.

\subsubsection{Object Overhead Issues}
\label{sec:object-overhead}


Modeling Eugene-Springfield (a relatively small metropolitan region)
requires some 350,000 objects to be represented in the
Object Store.  If these were represented as ordinary Java objects in our
current Java implementation (Sun Java 2.0), there would be an additional
overhead of approximately 20 bytes per object, for a total of seven
megabytes.  A larger region such as Salt Lake City requires some 1.5
million objects.  Given the typical access patterns for the fields of
objects (Section \ref{sec:swapping}), performance is much improved if all
the objects can be held in main memory, and so reducing space overhead is
important.

Therefore, we represent objects efficiently within the Object Store, using
parallel arrays holding the fields of each object type.  For example, each
\varnm{Household} object includes a integer field to hold its location,
and a byte field to hold its income category.  Rather than
storing 300,000 explicit \varnm{Household} objects in the Object Store
(with the attendant object overhead), we hold the information in a series
of arrays, including an integer array \varnm{Location} with 300,000
elements, a 300,000 element byte array for income categories, and so forth.

Since these fields almost always hold primitive Java types such as
\keyw{floats} or \keyw{ints}, rather than reference types, storing the
fields directly in large arrays eliminates most of the space overhead.  It
also eliminates wasted space in each object due to word alignment padding,
as would arise for byte fields.  The encapsulation provided by the Object
Store means that this non-standard representation is not visible outside
it.

Other data structures have been implemented in a lightweight fashion, such as
dynamic arrays, hash sets, and hash tables, to allow for storage of primitive
types (\keyw{ints}, \keyw{floats}, etc.) in a fashion that eliminates the
Java object-level overhead present from using Java's built-in data
structures such as the \varnm{ArrayList} and \varnm{HashMap}.

\subsubsection{Construction of Object Class Definitions}
\label{sec:object-definition}

Objects in the Object Store consist of the union of all fields
defined by models for each object type and by the set of default
object definitions (which are shared by most models).  Queries can
return copies of any of the fields of objects, and updates can
modify fields or create or remove instances of objects.  The
Object Store's functionality has been tailored to the needs of
UrbanSim-style models, including the ability to perform spatial
queries on geo-referenced data (a task poorly performed by
traditional databases).

The complete definition of each object type, and the Java code used to
access and query it, is generated automatically from these partial object
descriptions.  For example, the \varnm{Zone} object type represents a
traffic analysis zone.  Partial definitions of \varnm{Zone} are given by
both the default object definitions
%(Figure~\ref{fig:DefaultObjZoneObjDef})
and the Developer Model
%(Figure~\ref{fig:DeveloperZoneObjDef}).
These definitions are combined, and used to generate the final
version of the \varnm{Zone} object.
Query/Update access methods, and routines that 
enable objects to be saved or loaded from disk, are 
generated automatically as well.
%(Figure~\ref{fig:AutogenAccessorMethods}).


%\begin{figure}
%\begin{tabbing}
%\quad \=\quad \=\quad \kill
%\keyw{class} \varnm{Zone}                    \\
%\keyw{shared read int} \varnm{ZoneID}        \\
%\keyw{read float[]} \varnm{LandPricePerAcre} \\
%\keyw{read float[]} \varnm{TotalAcresByALU}  \\
%\keyw{read float[]} \varnm{UsedAcresByALU}   \\
%\keyw{read float[]} \varnm{TotalValueByALU}  \\
%\keyw{read int[]} \varnm{TotalSqftByALU}     \\
%\keyw{read int[]} \varnm{UsedSqftByALU}      \\
%\end{tabbing}
%\caption{Definition of a \varnm{Zone} Object from the Developer Model.}
%\label{fig:DeveloperZoneObjDef}
%\end{figure}

%\begin{figure}
%\begin{tabbing}
%\quad \=\quad          \kill
%\keyw{class} \varnm{Zone}      \\
%\keyw{read int} \varnm{ZoneID} \\
%\end{tabbing}
%\caption{Definition of a \varnm{Zone} Object from the default object
%definitions.}
%\label{fig:DefaultObjZoneObjDef}
%\end{figure}

%\begin{figure}
%\begin{tabbing}
%\quad \=\quad \=\quad                                                \kill
%\keyw{public class} \varnm{DBArray} \{                             \\
%\> ...                                                              \\
%\> // Fields for ZONE                                               \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayI ZONE\_ZoneID}
%=
%        \keyw{null}; \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayF ZONE\_LandPricePerAcre} =
%        \keyw{null};  \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayF ZONE\_UsedAcresByALU} =
%        \keyw{null};  \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayF ZONE\_TotalAcresByALU} =
%        \keyw{null};  \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayF ZONE\_TotalValueBYALU} =
%        \keyw{null};  \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayI ZONE\_TotalSqftByALU} =
%        \keyw{null};  \\
%\> \keyw{public static} \varnm{SimpleDynamicArrayI ZONE\_UsedSqftByALU} =
%        \keyw{null};  \\
%\> ... \\
%\}
%\end{tabbing}
%\caption{Combined definition of \varnm{Zone} object (excerpt).  Note the
%use of lightweight dynamic data structures, such as the
%\varnm{SimpleDynamicArrayI} array used to store integers while avoiding
%the Java object-level memory overhead from the \varnm{ArrayList} or
%\varnm{Vector} built-in data structures.}
%\label{fig:CombinedZoneObjDef}
%\end{figure}

%\begin{figure}
%\begin{tabbing}
%\quad \=\quad \=\quad \=\quad \=\quad \=\quad \=\quad          \kill
%// Get the value of the corresponding field of an object, as an \keyw{int} \\
%\keyw{public static final int} \varnm{getFieldI}(\keyw{int}
%        \varnm{objType}, \keyw{int}
%        \varnm{objIdx}, \keyw{int} \varnm{fieldID}) \{ \\
%\> ...                                 \\
%\> \keyw{switch} ( \varnm{objType} ) \{        \\
%\>\> \keyw{case} \varnm{DBObjTypes.ZONE}:      \\
%\>\>\> ...                             \\
%\>\>\> \keyw{switch} ( \varnm{fieldID} ) \{    \\
%\>\>\>\>  \keyw{case} \varnm{DBObjTypes.ZONE\_ZONEID}:                  \\
%\>\>\>\>\>  \keyw{return}
%        \varnm{DBArray.ZONE\_ZoneID.getI}(\varnm{objIdx});             \\
%\>\>\>\>  \keyw{default}:                                                \\
%\>\>\>\>\>  \keyw{throw new} \varnm{RuntimeException}(``Get fieldID '' +
%              \varnm{fieldID}   \\
%\>\>\>\>\>\>    + `` not found for object type ZONE, field type int''); \\
%\>\>\> \} \\
%\>\> ...  \\
%\> \}     \\
%\}        \\
%\end{tabbing}
%\caption{Automatically generated \varnm{Zone} Object accessor methods
%(excerpt)}
%\label{fig:AutogenAccessorMethods}
%\end{figure}

\subsubsection{Swapping}
\label{sec:swapping}

The contents of the Object Store may be too large for the
available main memory.  To handle this, we provide a simple
swapping mechanism that allows an array holding the contents of a
field for an object type, e.g.\ the \varnm{Location} field from
the \varnm{Household} type (Section \ref{sec:object-overhead}), to
be written out to disk if need be.  This mechanism reflects the
typical access patterns of models, which generally access every
object of a given type, but only a small number of fields of each
such object.  (The more typical unit of swapping is the
object---but given this access pattern, swapping on a per-object
basis would be less desirable, since we would swap in entire
objects, even most of the fields would not be immediately needed.)
However, it is still preferable if possible to keep all data in
main memory, since all of it is touched during each simulated
year.  Thus far, we have not used a commercial database as a back
end, due to a desire to not tie the Open Source UrbanSim code to a
proprietary system. However, we plan to offer access to commercial
databases as an option (but not a requirement) in a future
version.
% LocalWords:  Exp UrbanSim  UsedSqft TotalSqft ints java accessor  noth IDs
% LocalWords:  postQuery postUpdate EqualityFilter QueryResult Java's ArrayList
% LocalWords:  HashMap store's DBArray int ZoneID LandPricePerAcre oneID objIdx
% LocalWords:  TotalAcresByALU UsedAcresByALU TotalValueByALU TotalSqftByALU
% LocalWords:  UsedSqftByALU SimpleDynamicArrayI SimpleDynamicArrayF getFieldI
% LocalWords:  andPricePerAcre sedAcresByALU otalAcresByALU otalValueBYALU getI
% LocalWords:  otalSqftByALU sedSqftByALU objType fieldID DBObjTypes pwaddell
% LocalWords:  RuntimeException geo
