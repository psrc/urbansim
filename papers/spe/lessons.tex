%% $Id: lessons.tex,v 1.26 2001/08/18 01:15:58 borning Exp $

\section{Experience and Lessons Learned}
\label{sec:experience}


Perhaps the most important software lesson learned from this work has been
the value of moving as much of the complex functionality out of the
individual models and into the supporting infrastructure as possible; most
of the specific lessons discussed below are ways of achieving this goal.

% REMAINDER OF PARAGRAPH MOVED TO OVERVIEW:
% The supporting infrastructure need be written just once, and can have the
% attention of an expert programmer.  The models, on the other hand, are both
% numerous and frequently changing.  Often, specifying them is a complex
% process, involving considerable domain-specific knowledge and testing; the
% more one can relieve the model writers of programming burdens the better,
% so that they can concentrate on issues arising from the domain.

%*** more about how it has held up ***
% Some added; I think we could add quite a bit more about the conversion from
% parcel-level to gridcell-based land usage (i.e. non-spatial to spatial, etc).
% [MEN 8/2/00 8:15 PM]

% maybe convert the above list to bullet format, if it gets any longer [Alan]

\subsection{Implicit Invocation}
\label{sec:implicit-invocation}

Models do not communicate directly with each other, but rather communicate
by registering interest in objects and fields
held in the Object Store, and by being notified when such an object or field
has been changed by another model.  The architecture thus uses a form of
implicit invocation
\citep{garland-aske-1993,sullivan-tse-1992,sullivan-tse-1996},
in which components interact by generating and responding to events, rather
than by explicitly invoking each other's methods.  As in other systems,
implicit invocation has proven to be a powerful technique for addressing
component interaction complexity in UrbanSim.  Two advantages of using
implicit invocation have been:

\begin{itemize}

\item the ability to decouple models, since each model registers interest
in objects and fields, makes changes to the Object Store, and responds to
changes independently of the other models.  This has made it significantly
easier to experiment with new models and to evolve existing ones.

\item ensuring a consistent interface for model interactions, since
all interactions occur via the Object Store.

\end{itemize}

While our implicit invocation mechanism has worked well for the current
style of models, we expect that it would break down if we moved to a much
finer-grained simulation, for example, one in which households could
move, developers could begin constructing new buildings, 
and so forth, at any
time, rather than on a yearly basis.  The anticipated problems arise from
the current mechanism being relatively coarse-grained: in the current
architecture, a model cannot specify that it wishes to monitor a field in a
particular object, only that it wishes to monitor a field in all objects of
a given type.  Any additional filtering or selection must occur within the
callback code that is executed within the model as a result of the
notification.  This has been quite acceptable in the current system, but
could introduce excessive numbers of unnecessary notifications in a more
fine-grained approach, leading to unacceptably slow execution speeds.

A related difficulty is that the complexity of the callback code increases
as more models use it to monitor and update related fields.  For example,
adding a new model that affects the existing functionality embedded in
notification methods requires that the callback code in the new model take
into account all of the existing functionality and not override or
invalidate any of its actions.

\subsection{Explicit versus Implicit Execution Ordering}

We originally intended to handle most of the specification of model
execution ordering using implicit data-level dependencies (Section
\ref{sec:event-queue}).  However, experience showed that the simple
data-level ordering dependency rules (all reads to a field before any
writes to it) failed to capture many important semantic constraints on
model execution ordering.  Thus in practice, the bulk of ordering
dependencies are specified explicitly by model creators.

We also allow user-supplied model-level ordering dependencies to override
data-level ones.  For example, the Export Model
only reads from the Object Store and never writes to it.  The
implicit data-level dependencies would require that it run before
other models.  However, we use an explicit ordering constraint to require
that it be run \emph{after} all the other models, so that it exports the
information after the simulation has completed for the current simulated
instant of time.  However, if there are ordering dependency conflicts at
the same level (i.e., at the model-level, or at the data-level in the
absence of any overriding model-level dependencies), an error will be
signaled.

The current design has worked well in practice, but is not entirely
satisfying, and may begin to cause problems if the number of models
increases dramatically.  At that point we expect we will need to re-examine
the issue, and perhaps find more sophisticated ways to determine implicit
ordering constraints that reduce the need for explicit orderings.

\subsection{Object Storage and Representation}

Java's overhead for object representation (specifically, the class tag and
the overhead of word alignment padding) has made the overhead of using
standard Java objects in the Object Store prohibitive.  Instead, we use a
nonstandard object representation, namely parallel arrays holding the
fields of each object type.  However, this is not visible outside of the
Object Store's encapsulation boundary.
This solution is not new to UrbanSim: it is akin to the use of
marshalling in Smalltalk, CORBA, Java, etc.  It is also more loosely
related to the concept of flyweight objects
\citep{calder-uist-1990,gamma-book-1995}, although unlike flyweight objects,
objects in the UrbanSim Object Store do not have extrinsic state that
depends on their context.

The approach has had enormous benefits in the context of UrbanSim.  Memory
requirements have decreased by a factor of seven or more as compared with
the original object-based implementation, making the simulation of large
areas such as Salt Lake City, Utah feasible on modest desktop systems.  It
has also facilitated the addition of disk-based swapping to the Object
Store to handle cases in which the simulation's storage requirements still
exceed the available memory.

\subsection{Automatic Generation of Code from Declarative Specifications}

We have made considerable use in UrbanSim of the technique of generating
Java code automatically from declarative specifications.  One example is
the generation of object class definitions for objects in the Object Store,
along with query and update methods (Section \ref{sec:object-definition}).
The automatic generation of Java code that defines objects and their
interface with the Object Store removes much programming burden from
experimenters who introduce a new model or replace an existing one, as they
do not have to write code that defines or manipulates object types.  (This
is particularly important since we use a non-standard representation of objects
within the Object Store.)  It also ensures that a consistent interface
exists between the Object Store and every object that is contained within
it.

We have also used automatic generation of Java code to define specialized,
lightweight data structures optimized to store primitive Java types
(\keyw{ints}, \keyw{floats}, etc.) with a minimum of memory overhead.
These include lightweight dynamic arrays (\varnm{SimpleDynamicArray}),
lightweight hash tables and sets (\varnm{HashTableIntInt},
\varnm{HashSetInt}, \varnm{HashSetFloat}, etc.), and some additional
wrapper objects.

The issue addressed by these lightweight data structures is that in the
standard Java library there is just one class definition for e.g.\
\varnm{HashSet}, whose element type is \varnm{Object}.  Therefore, to
store \keyw{ints} in a standard hash set, each \keyw{int} must be wrapped
using the \varnm{Integer} class, leading to a considerable overhead in
both space and time.  Our automatically-generated \varnm{HashSetInt} class
eliminates this overhead.  If sufficiently powerful generic types were
incorporated in future versions of Java, the need for these specialized
lightweight data structures would be eliminated (or more precisely, they
would be generated by the Java system itself rather than by us).
Note that to be useful for our purposes, such a design must provide
heterogeneous, not homogeneous, translation of generic types---homogeneous
translation does not handle the space overhead problem.  (In heterogenous
translation, the compiler produces different versions of the code for each
instantiated type; in homogeneous translation, just one version.  For Java,
homogeneous translation requires wrapping each primitive type, which
adds a tremendous space penalty.  Both varieties of
translation are available in the Pizza extension to Java
\citep{odersky-popl-1997}; GJ \citep{bracha-oopsla-1998} and NextGen
\citep{cartwright-oopsla-1998} provide only homogeneous translation.)


\subsection{Choice of Programming Language}

UrbanSim is implemented in the Java programming language.
Java has provided a solid environment for implementing a system of this
kind, particular strengths being automatic storage management, static
typing, a rich class library, and portability.  While its execution speed
is not comparable to C++, current compiler technology (e.g., Just-In-Time
compilation) has provided reasonable performance.  Perhaps the biggest
problem for us has been the overhead of object representation, which has
required unorthodox object representations within the Object Store (Section
\ref{sec:object-store}).

Java provides many
advantages over other programming languages that were considered.
% OMITTED THIS, since C++ is (arguably) object-oriented: such as {C++}.
These advantages include:
 \begin{itemize}
 \item
 Object-oriented language, where we can use inheritance and subclassing to
 increase reusability of language-level objects and code we write;
 \item
 Automatic storage management, which helps improve software reliability by
 eliminating memory allocation and storage errors that can be difficult to
 find and fix in other environments;
 \item
 A rich collection of data structures and libraries, which improves
 productivity when writing code;
 \item
 Portability, so that we can run the UrbanSim model on a variety of
 platforms without needing to modify the source code;
 \item
 Performance, which is reasonably good due to the use of Just-In-Time ({JIT})
 compilers, and is substantially better than interpreted languages.
 \end{itemize}
We considered using one of the dedicated modeling languages or
environments which are available, such as Stella,
Swarm \citep{luna-2000,swarm-web}, StarLogo \citep{starlogo-java-web},
or the {MIMOSE} framework \citep{mohring-96}.
However, none of these met our requirements for portability,
generality, and efficiency.  We thus chose to implement a framework
from scratch, enabling us to customize and optimize it for the specific
domain and types of models we work with.

\subsection{An Open Source Software Approach}

The UrbanSim software is licensed under the GNU General Public License
(GPL) from the Free Software Foundation.  This license is well-known among
software developers, and is used for such systems as the linux operating
system and the emacs text editor.  It is not so commonly used for software
for urban modeling, but has some significant benefits.  The license allows
anyone who has the software to further distribute it, to change it, or to
use parts of it in new programs.  Further, it requires that any
distribution of the system or of derivative works continue to be licensed
under the GPL\@.  The distribution must include the source code as well as
the compiled object code, or make the source code easily available.
(Please see the GPL itself \citep{gpl-web} for the precise terms of the
license.)

The benefits of licensing UrbanSim under the GNU General Public License are
that other researchers and practitioners can freely apply the software, as
well as build on it and distribute those results as well.  In contrast, a
proprietary license would typically require the payment of fees, and might
well not include the source code.  Using the GPL license also has quite
different implications from placing the source code in the public domain:
if this were done, the version in the public domain would be freely
available, but someone else could produce a derivative work (perhaps involving
changes to a relatively small percentage of the system), and then place
this derivative work under a restrictive, proprietary license.

The original implementation work on the software architecture
described in this paper was done by a single programmer (the first
author). Subsequently, however, portions of the infrastructure and
many of the models have been modified or created by others.  We
use the Concurrent Versions System (CVS)
\citep{cederqvist-cvs-2000} as a means of coordinating and
integrating programming work performed by the different
programmers who work on this project.  CVS maintains a central
repository with the definitive copy of the source code.  A
programmer checks out a copy of the system, which can be
freely modified on that programmer's personal disk directory. When
the new version is ready, the programmer can then check it in to
the repository.  CVS keeps track of the different versions of the
system, and watches for conflicting check-ins by different
programmers, notifying them so that the differences can be
resolved.

CVS is often used for Open Source development projects, since it is
admirably suited to coordinating the work of programmers at geographically
distributed locations.  Another feature of CVS is that the developers can
allow anyone read-only access to the repository, so that others can track
the latest versions of the software.  We have not yet used these features,
but plan to in the near future as a way of coordinating work with a
Metropolitan Planning Organization that will be applying UrbanSim to that
region.

% LocalWords:  Exp autogeneration UrbanSim SPE subclassing reusability JIT noth
% LocalWords:  CVS gridcell marshalling AP Smalltalk callback Java's store's GJ
% LocalWords:  CORBA ints SimpleDynamicArray HashTableIntInt HashSetInt HashSet
% LocalWords:  HashSetFloat int cvs pwaddell centric flyweight ashSet NextGen
% LocalWords:  GPL linux
