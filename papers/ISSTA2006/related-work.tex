% $Id: related-work.tex,v 1.22 2006/01/28 02:32:29 borning Exp $

\section{Related Work}

% stochastic tests are different than tests of stochastic algorithms

% general
Testing software against various conditions during development is a well 
established software engineering practice to ensure quality and find errors 
early in the development process \cite{mcgregor:2001,sommerville:2001}.  Not 
only is well-tested software essential to guarantee its functionality, 
in the urban planning domain it is
also a way to enhance the project's credibility and its acceptance in 
disputed decision-making processes. The easily available source code (under an 
open source license), together with an accompanying set of tests, allows 
anybody to cross check the system. Moreover, automated tests allow software 
developers to modify and evolve the system with increased confidence and 
safety. This becomes crucial when introducing external programmers to the team 
in a distributed open source development process. 

% Still, tests can only help find errors---they cannot prove the correctness
% of the code

The UrbanSim software is being developed using an agile development process
\cite{beck:2000}, which relies on small, incremental development steps.  This
is achieved in part by pursuing a test-first development strategy using a
modified eXtreme Programming approach \cite{beck:2003}.  
Agile development processes (including
ours) often rely on an automatic build system~\cite{fowler:2006}, which not
only compiles the program and makes sure that static relations can be
resolved, but also executes all tests provided.

\subsection{Unit Tests}
\label{related-work-unit-tests}

To help ensure the code quality of UrbanSim, we use unit tests 
\cite{beckgamma,hunt:2003,Noonan:2002} to automatically 
test Python classes (previously, Java classes) and their operations.
The underlying assumption of 
existing unit test frameworks is that the unit under test
has a deterministic behavior. Therefore, tests can assume an initial 
state when creating an instance of that particular class. Consequently, each 
operation modifies the instance's state in a deterministic way. Probing the 
instance's state will result in a repeatable constant value. By applying 
classic unit tests, 
we implicitly deal with deterministic finite state machines.

The vast majority of the testing literature deals with such deterministic
finite state machines \cite{lee:1996,sidhu:1989,yannakakis:1991}, in which
test cases are considered to be action sequences, and the tester is assumed
to be in full control of the state of the unit under test.

\subsection{Testing Nondeterministic Systems}

Most simulation systems, including UrbanSim, rely on random numbers
to simulate nondeterministic real-world behaviors.  It is
possible to make the system deterministic by fixing the seed for the random
number generator, but we found the resulting tests to be problematic
(see Section \ref{prior-experience}).  If we view the simulation system instead
as a nondeterministic one, there is considerably less prior work on testing on
which to draw.  In particular, by introducing a source of randomness into a
program, our deterministic unit changes to nondeterministic behavior,
breaking a key assumption for unit tests.  Now, if we implement tests in a
straightforward fashion, they can fail even though the implementation is
correct.

% Leinwand introduces the notion of nodeterministic behaviour of digital systems 
% \cite[p.~483]{leinwand:1980}. Such systems can experiences 
% changes that are not only dependent on the input and the starting state but on 
% an implementation detail that is not totally controlable. In this case of 
% simulation software we willingly accept that the random number generator 
% produces sequeneces of numbers that are not controlable.

Nachmanson et al.\@ address the problem of testing nondeterministic systems by 
means of game theory \cite{nachmanson:2004}. They model all states by a graph 
representing choice points and transitions as edges. Their aim is to identify 
the fastest strategies to cover the complete graph. This method is applicable 
for finite state machines with small numbers of states and transitions.
However, in our case we are dealing with huge sets of input data and a large
number of choices (e.g.\ relocating 10,000 households into potential
residential locations on a grid of $1,000\times 1,000$), making this
approach infeasible.

The problem of nondeterminism arises in many other applications in addition
to simulation, for example, in message-passing systems
\cite{kranzmuller:1998} and communication protocols in general.  Chen et
al.\@ state that in testing nondeterministic systems it may not be
sufficient to run a test once \cite[p.~217]{chen:1994}. However, they do
not provide a statistical analysis of the consequences of doing this.  (For
example, how many times should the test be run before one decides that it
has failed?  If the test succeeds, what confidence does that provide that
the system is correct?  Perhaps the test succeeded by chance.) They further
argue that it would be necessary to compute the transitive closure of
references to all entities of the unit under test.  However, this would be
quite resource-consuming (time and/or memory), and so not really
appropriate for a unit test approach.


% identifying the initial state of a finite state machine
% \cite{alur:1995} not relevant for ths paper

% s, p, and e programs %
% This is very much in line with Lehmann's distinction of real-world 
% problems\cite[pp.~7-14]{lehman-1980}. He introduces three categories: ``s'', 
% ``p'', and ``e'' programs. ``s''-programs can be \emph{specified} to the last 
% detail and can even be proved correct. 
% A sorting algorithm is an example of such a 
% program.  While ``s''-programs do their task they have a small scope 
% and limited 
% applicability. ``p''-programs solve \emph{problems}. A chess program is an 
% example for such a program. Even though it is far more complex than an 
% ``e''-program it has little relation to real-world problems and it is limited 
% to its closed world. ``e'' programs, however, are \emph{embedded}. Therefor 
% they are in direct feedback loop with the surrounding world in which the system 
% is used. This serves as ...


% The strategy pursued in this approach takes into account the knowledge about the
% characteristics of the statistical function
% 
% However, we are able to specify the distribution of the result set due to the 
% characteristics of the given probabilistic function. We therefore formulate the 
% criteria for a successful test run on the basis of the statistical 
% characteristics of the resulting data set. Still, these characteristics can 
% only be met with a sufficient number of elements.


% LocalWords:  borning Lehmann's tex jan wgb UrbanSim eXtreme testrunner al
% LocalWords:  refactorings Nachmanson lehman hana

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
