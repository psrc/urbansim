# Opus/UrbanSim urban simulation software.
# Copyright (C) 2005-2009 University of Washington
# See opus_core/LICENSE

from NumPtr import getpointer
from numpy import where, zeros, float64, float32, array
from opus_core.estimation_procedure import EstimationProcedure
from opus_core.logger import logger
from opus_core.misc import ematch
import biogeme
import os
import tempfile
#import pdb

class mnl_estimation(EstimationProcedure):
    """
    The module runs an MNL estimation via biogeme. It should be plugged-in into a method 'estimate' of ChoiceModel or
    its children (as 'procedure' argument). Control parameters for this module can be passed via the argument 'estimate_config'.
    These are:
     - If the estimation should be run using an existing model file (model_name.mod), set 'skip_generating_model_file' to True (False is default).
     - 'biogeme_model_name' is the name of the model (including its path). If it is missing and 'skip_generating_model_file' is True,
         it is set to 'default'. If 'skip_generating_model_file' is False, it is set to 'autogenerated' in a temporary directory.
     - 'biogeme_settings' - Various settings for the model file if it is created automatically (as a dictionary/Configuration).
         The entries correspond to sections in the model file as described in the documentation of biogeme.
         E.g.:
         { "Beta": { "value": value,
                     "LowerBound": value,
                     "UpperBound": value,
                     "status": value
                     }
         }
    """
    def run(self, data, upc_sequence, resources):
        """
        'data' is of shape (nobservations, nchoices, nvariables).
        """

        nobs, alts, nvars = data.shape
        if resources.get("skip_generating_model_file", False):
            model_name = resources.get("biogeme_model_name", "default")
        else:
            model_name = create_model_file(alts, resources)



        choice_matrix = resources["chosen_choice"] # matrix (nobs x alts) of 0's and 1's. 1 is on positions of chosen location.
        chosen_choice = where(choice_matrix)[1] + 1
        # flatten data into 2d
        var_names = resources["specified_coefficients"].get_variable_names_from_alt()

        index_of_non_constants = []
        for i in range(nvars):
            if not (var_names[i] == "constant"):
                index_of_non_constants.append(i)

        index_of_non_constants = array(index_of_non_constants)
        nvars_without_const = index_of_non_constants.size
        data_for_biogeme = zeros((nobs, alts*nvars_without_const + 1), dtype=float64)

        biogeme_var_names = []
        for ivar in range(nvars_without_const):
            for ialt in range(alts):
                biogeme_var_names.append(var_names[index_of_non_constants[ivar]] + "_" + str(ialt+1))
                data_for_biogeme[:,ivar*alts+ialt] = data[:,ialt, index_of_non_constants[ivar]]

        data_for_biogeme[:, alts*nvars_without_const] = chosen_choice
        a_ptr = getpointer(data_for_biogeme)

        #
        # Prepare data headers
        #

        ncols = data_for_biogeme.shape[1]
        headers = biogeme.vectorStr(ncols) ;

        for i in range(ncols-1):
            headers[i] = biogeme_var_names[i]
        headers[ncols-1]="choice"

        #
        # Define variables for the results
        #

        estimationResults = biogeme.patPythonResults()
        #
        # Invoke biogeme
        #

        biogemeObject = biogeme.patBiogemeScripting()
        biogemeObject.estimate(model_name,a_ptr,nobs,ncols,headers,estimationResults)

        #
        # Use the results
        #

        print " timeStamp: ",  estimationResults.getTimeStamp() ;

        print " version: ", estimationResults.getVersion() ;

        print " description: ", estimationResults.getDescription() ;

        print " model: ", estimationResults.getModel() ;

        print " drawsType: ", estimationResults.getDrawsType() ;

        print " numberOfDraws: ", estimationResults.numberOfDraws ;

        print " numberOfParameters: ", estimationResults.numberOfParameters ;

        print " numberOfObservations: ", estimationResults.numberOfObservations ;

        print " numberOfIndividuals: ", estimationResults.numberOfIndividuals;

        print " nullLogLikelihood: ", estimationResults.nullLoglikelihood ;

        print " initLoglikelihood: ", estimationResults.initLoglikelihood ;

        print " finalLoglikelihood: ", estimationResults.finalLoglikelihood ;

        print " likelihoodRatioTest: ", estimationResults.likelihoodRatioTest ;

        print " rhoSquare: ", estimationResults.rhoSquare ;

        print " rhoBarSquare: ", estimationResults.rhoBarSquare ;

        print " finalGradientNorm: ", estimationResults.finalGradientNorm ;

        print " varianceCovariance: ", estimationResults.getVarianceCovariance() ;
        print "Parameters\tEstimate\tStdErr\ttTest\tpValue";

        coef_names = resources["specified_coefficients"].get_coefficient_names_from_alt()
        est_values = zeros(coef_names.size, dtype=float32)
        std_errors = zeros(coef_names.size, dtype=float32)
        tstat = zeros(coef_names.size, dtype=float32)
        pvalues = zeros(coef_names.size, dtype=float32)

        for  i in range(estimationResults.totalNumberOfParameters):
            if (estimationResults.getFixed(i)):
                print estimationResults.getParamName(i)," is fixed" ;
            else:
                name = estimationResults.getParamName(i)
                idx = ematch(coef_names, name)[0]
                print name , '\t',\
                      estimationResults.getEstimate(i), '\t',\
                      estimationResults.getStdErrRobust(i),'\t',\
                      estimationResults.getTTestRobust(i),'\t',\
                      estimationResults.getPValueRobust(i) ;
                #print "Check... " , estimationResults.getEstimate(estimationResults.getParamName(i)) ;
                est_values[idx] = estimationResults.getEstimate(i)
                std_errors[idx] = estimationResults.getStdErrRobust(i)
                tstat[idx] = estimationResults.getTTestRobust(i)
                pvalues[idx] = estimationResults.getPValueRobust(i)
        logger.log_status("Biogeme model: ", model_name)
        return {"estimators":est_values, "standard_errors":std_errors,
                "other_measures":{"t_statistic": tstat, "p_values": pvalues},
                "other_info":{"ll_ratio_index":1-(estimationResults.finalLoglikelihood/estimationResults.nullLoglikelihood),
                              "ll_ratio_test_statistics":estimationResults.likelihoodRatioTest,
                              "nobs":estimationResults.numberOfObservations,
                              "Rho-Square":estimationResults.rhoSquare,
                              "Rho-bar-Square":estimationResults.rhoBarSquare}}

def create_model_file(nalts, resources):
    coefficients = resources["specified_coefficients"]
    var_names = coefficients.get_variable_names_from_alt()
    coef_names = coefficients.get_coefficient_names_from_alt()
    coefvalues = coefficients.get_beta_alt()

    model_name = resources.get("biogeme_model_name",
                               os.path.join(tempfile.mkdtemp(prefix='biogeme_tmp'), "autogenerated"))
    settings = resources.get("biogeme_settings", {})
    fd = open(model_name+'.mod', 'w')
    fd.write("// This is automatically generated biogeme model file.\n")
    fd.write("[Choice]\n")
    fd.write("choice\n\n")
    fd.write("[Beta]\n")
    fd.write("// Name\tValue\tLowerBound\tUpperBound\tstatus (0=variable, 1=fixed)\n")
    beta_config = settings.get("Beta", {})
    for coef in coef_names:
        coef_config = beta_config.get(coef, {})
        fd.write("%s\t%s\t%s\t%s\t%s\n" % (coef, coef_config.get("value", 0.0),
                 coef_config.get("LowerBound", -100.0), coef_config.get("UpperBound", 100.0),
                 coef_config.get("status", 0)))

    fd.write("\n[Utilities]\n")
    fd.write("// Id\tName\tAvail\tlinear-in-parameter expression (beta1*x1 + beta2*x2 + ... )\n")
    for ialt in range(nalts):
        fd.write("%s\tA%s \tavail\t" % (ialt+1, ialt+1))
        flag = False
        for ivar in range(len(var_names)):
            if coefvalues[ialt,ivar] <> 0:
                if flag:
                    fd.write(" + ")
                fd.write("%s * %s" % (coef_names[ivar], var_names[ivar]))
                flag = True
                if var_names[ivar] <> "constant":
                    fd.write("_%s" % (ialt+1))
        if flag:
            fd.write(" \n")

    fd.write("\n[Expressions]\n")
    fd.write("constant = 1\n")
    fd.write("avail = 1\n")
    fd.write("\n[Model]\n")
    fd.write("$MNL\n")

    fd.flush()
    fd.close()
    return model_name